
import { GoogleGenAI, Chat, GenerateContentResponse } from "@google/genai";

class GeminiService {
  private ai: GoogleGenAI;
  private readonly textModelName = 'gemini-2.5-flash-preview-04-17';
  private readonly imageModelName = 'imagen-3.0-generate-002';

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error("Gemini API key is required.");
    }
    this.ai = new GoogleGenAI({ apiKey });
  }

  startChat(systemInstruction?: string): Chat {
    return this.ai.chats.create({
      model: this.textModelName,
      config: {
        systemInstruction: systemInstruction || "You are a helpful and friendly AI assistant.",
      },
    });
  }

  async sendMessageStream(
    chat: Chat,
    message: string
  ): Promise<AsyncIterable<GenerateContentResponse>> {
    if (!chat) {
        throw new Error("Chat session not initialized.");
    }
    return chat.sendMessageStream({ message });
  }

  async generateImagesFromPrompt(prompt: string, numberOfImages: number = 1): Promise<string[]> {
    try {
      const response = await this.ai.models.generateImages({
        model: this.imageModelName,
        prompt: prompt,
        config: { numberOfImages: numberOfImages, outputMimeType: 'image/jpeg' },
      });
      
      if (!response.generatedImages || response.generatedImages.length === 0) {
        throw new Error("No images were generated by the AI.");
      }

      return response.generatedImages.map(img => {
        if (!img.image || !img.image.imageBytes) {
          throw new Error("Generated image data is incomplete.");
        }
        return `data:image/jpeg;base64,${img.image.imageBytes}`;
      });
    } catch (error) {
      console.error("Error generating images:", error);
      // Re-throw a more user-friendly or specific error if needed, or handle it appropriately
      if (error instanceof Error) {
        throw new Error(`Image generation failed: ${error.message}`);
      }
      throw new Error("An unknown error occurred during image generation.");
    }
  }
}

export default GeminiService;
